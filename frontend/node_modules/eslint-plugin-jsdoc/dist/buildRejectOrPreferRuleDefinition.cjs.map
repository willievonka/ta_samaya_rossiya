{"version":3,"file":"buildRejectOrPreferRuleDefinition.cjs","names":["_iterateJsdoc","_interopRequireDefault","require","_jsdoccomment","e","__esModule","default","adjustNames","type","preferred","isGenericMatch","typeNodeName","node","parentNode","ret","parentMeta","meta","brackets","dot","dotBracketEnd","match","slice","length","bracketEnd","endsWith","value","replace","getMessage","upperCase","info","message","replacement","infoUC","buildRejectOrPreferRuleDefinition","checkNativeTypes","typeName","description","overrideSettings","schema","url","iterateJsdoc","context","jsdocNode","report","settings","sourceCode","utils","jsdocTagsWithPossibleType","filterTags","tag","Boolean","tagMightHaveTypePosition","mode","preferredTypes","preferredTypesOriginal","structuredTags","injectObjectPreferredTypes","typeToInject","Object","exemptTagContexts","noDefaults","unifyParentAndChildTypeChecks","options","getPreferredTypeInfo","_type","property","hasMatchingPreferredType","typName","isNameOfGeneric","undefined","checkPostFixes","some","checkPostFix","preferredType","prefType","directNameMatch","values","includes","specificUnify","unifiedSyntaxParentMatch","getInvalidTypes","tagName","nameInTag","idx","invalidTypes","types","preferredSetting","push","nextItem","skipRootChecking","name","startsWith","reportSettings","entries","typs","Array","isArray","jsdocTag","typeAst","tryParse","parse","traverse","fixedType","stringify","fix","fixer","replaceText","getText","badType","msg","tagValue","JSON","iterateAllJsdocs","docs","os","fixable","exports"],"sources":["../src/buildRejectOrPreferRuleDefinition.js"],"sourcesContent":["import iterateJsdoc from './iterateJsdoc.js';\nimport {\n  parse,\n  stringify,\n  traverse,\n  tryParse,\n} from '@es-joy/jsdoccomment';\n\n/**\n * Adjusts the parent type node `meta` for generic matches (or type node\n * `type` for `JsdocTypeAny`) and sets the type node `value`.\n * @param {string} type The actual type\n * @param {string} preferred The preferred type\n * @param {boolean} isGenericMatch\n * @param {string} typeNodeName\n * @param {import('jsdoc-type-pratt-parser').NonRootResult} node\n * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n * @returns {void}\n */\nconst adjustNames = (type, preferred, isGenericMatch, typeNodeName, node, parentNode) => {\n  let ret = preferred;\n  if (isGenericMatch) {\n    const parentMeta = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n      parentNode\n    ).meta;\n    if (preferred === '[]') {\n      parentMeta.brackets = 'square';\n      parentMeta.dot = false;\n      ret = 'Array';\n    } else {\n      const dotBracketEnd = preferred.match(/\\.(?:<>)?$/v);\n      if (dotBracketEnd) {\n        parentMeta.brackets = 'angle';\n        parentMeta.dot = true;\n        ret = preferred.slice(0, -dotBracketEnd[0].length);\n      } else {\n        const bracketEnd = preferred.endsWith('<>');\n        if (bracketEnd) {\n          parentMeta.brackets = 'angle';\n          parentMeta.dot = false;\n          ret = preferred.slice(0, -2);\n        } else if (\n          parentMeta?.brackets === 'square' &&\n          (typeNodeName === '[]' || typeNodeName === 'Array')\n        ) {\n          parentMeta.brackets = 'angle';\n          parentMeta.dot = false;\n        }\n      }\n    }\n  } else if (type === 'JsdocTypeAny') {\n    node.type = 'JsdocTypeName';\n  }\n\n  /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n    node\n  ).value = ret.replace(/(?:\\.|<>|\\.<>|\\[\\])$/v, '');\n\n  // For bare pseudo-types like `<>`\n  if (!ret) {\n    /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n      node\n    ).value = typeNodeName;\n  }\n};\n\n/**\n * @param {boolean} [upperCase]\n * @returns {string}\n */\nconst getMessage = (upperCase) => {\n  return 'Use object shorthand or index signatures instead of ' +\n  '`' + (upperCase ? 'O' : 'o') + 'bject`, e.g., `{[key: string]: string}`';\n};\n\n/**\n * @type {{\n *   message: string,\n *   replacement: false\n * }}\n */\nconst info = {\n  message: getMessage(),\n  replacement: false,\n};\n\n/**\n * @type {{\n *   message: string,\n *   replacement: false\n * }}\n */\nconst infoUC = {\n  message: getMessage(true),\n  replacement: false,\n};\n\n/**\n * @param {{\n *   checkNativeTypes?: import('./rules/checkTypes.js').CheckNativeTypes|null\n *   overrideSettings?: import('./iterateJsdoc.js').Settings['preferredTypes']|null,\n *   description?: string,\n *   schema?: import('eslint').Rule.RuleMetaData['schema'],\n *   typeName?: string,\n *   url?: string,\n * }} cfg\n * @returns {import('@eslint/core').RuleDefinition<\n *   import('@eslint/core').RuleDefinitionTypeOptions\n * >}\n */\nexport const buildRejectOrPreferRuleDefinition = ({\n  checkNativeTypes = null,\n  typeName,\n  description = typeName ?? 'Reports types deemed invalid (customizable and with defaults, for preventing and/or recommending replacements).',\n  overrideSettings = null,\n  schema = [],\n  url = 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/check-types.md#repos-sticky-header',\n}) => {\n  return iterateJsdoc(\n    ({\n      context,\n      jsdocNode,\n      report,\n      settings,\n      sourceCode,\n      utils,\n    }) => {\n      const jsdocTagsWithPossibleType = utils.filterTags((tag) => {\n        return Boolean(utils.tagMightHaveTypePosition(tag.tag));\n      });\n\n      const\n        /**\n         * @type {{\n         *   preferredTypes: import('./iterateJsdoc.js').PreferredTypes,\n         *   structuredTags: import('./iterateJsdoc.js').StructuredTags,\n         *   mode: import('./jsdocUtils.js').ParserMode\n         * }}\n         */\n        {\n          mode,\n          preferredTypes: preferredTypesOriginal,\n          structuredTags,\n        } = overrideSettings ? {\n          mode: settings.mode,\n          preferredTypes: overrideSettings,\n          structuredTags: {},\n        } : settings;\n\n      const injectObjectPreferredTypes = !overrideSettings &&\n        !('Object' in preferredTypesOriginal ||\n        'object' in preferredTypesOriginal ||\n        'object.<>' in preferredTypesOriginal ||\n        'Object.<>' in preferredTypesOriginal ||\n        'object<>' in preferredTypesOriginal);\n\n      /** @type {import('./iterateJsdoc.js').PreferredTypes} */\n      const typeToInject = mode === 'typescript' ?\n        {\n          Object: 'object',\n          'object.<>': info,\n          'Object.<>': infoUC,\n          'object<>': info,\n          'Object<>': infoUC,\n        } :\n        {\n          Object: 'object',\n          'object.<>': 'Object<>',\n          'Object.<>': 'Object<>',\n          'object<>': 'Object<>',\n        };\n\n      /** @type {import('./iterateJsdoc.js').PreferredTypes} */\n      const preferredTypes = {\n        ...injectObjectPreferredTypes ?\n          typeToInject :\n          {},\n        ...preferredTypesOriginal,\n      };\n\n      const\n        /**\n         * @type {{\n         *   noDefaults: boolean,\n         *   unifyParentAndChildTypeChecks: boolean,\n         *   exemptTagContexts: ({\n         *     tag: string,\n         *     types: true|string[]\n         *   })[]\n         * }}\n         */ {\n          exemptTagContexts = [],\n          noDefaults,\n          unifyParentAndChildTypeChecks,\n        } = context.options[0] || {};\n\n      /**\n       * Gets information about the preferred type: whether there is a matching\n       * preferred type, what the type is, and whether it is a match to a generic.\n       * @param {string} _type Not currently in use\n       * @param {string} typeNodeName\n       * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n       * @param {string|undefined} property\n       * @returns {[hasMatchingPreferredType: boolean, typeName: string, isGenericMatch: boolean]}\n       */\n      const getPreferredTypeInfo = (_type, typeNodeName, parentNode, property) => {\n        let hasMatchingPreferredType = false;\n        let isGenericMatch = false;\n        let typName = typeNodeName;\n\n        const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';\n\n        const brackets = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n          parentNode\n        )?.meta?.brackets;\n        const dot = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n          parentNode\n        )?.meta?.dot;\n\n        if (brackets === 'angle') {\n          const checkPostFixes = dot ? [\n            '.', '.<>',\n          ] : [\n            '<>',\n          ];\n          isGenericMatch = checkPostFixes.some((checkPostFix) => {\n            const preferredType = preferredTypes?.[typeNodeName + checkPostFix];\n\n            // Does `unifyParentAndChildTypeChecks` need to be checked here?\n            if (\n              (unifyParentAndChildTypeChecks || isNameOfGeneric ||\n                /* c8 ignore next 2 -- If checking `unifyParentAndChildTypeChecks` */\n                (typeof preferredType === 'object' &&\n                  preferredType?.unifyParentAndChildTypeChecks)\n              ) &&\n              preferredType !== undefined\n            ) {\n              typName += checkPostFix;\n\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        if (\n          !isGenericMatch && property &&\n          /** @type {import('jsdoc-type-pratt-parser').NonRootResult} */ (\n            parentNode\n          ).type === 'JsdocTypeGeneric'\n        ) {\n          const checkPostFixes = dot ? [\n            '.', '.<>',\n          ] : [\n            brackets === 'angle' ? '<>' : '[]',\n          ];\n\n          isGenericMatch = checkPostFixes.some((checkPostFix) => {\n            const preferredType = preferredTypes?.[checkPostFix];\n            if (\n              // Does `unifyParentAndChildTypeChecks` need to be checked here?\n              (unifyParentAndChildTypeChecks || isNameOfGeneric ||\n                /* c8 ignore next 2 -- If checking `unifyParentAndChildTypeChecks` */\n                (typeof preferredType === 'object' &&\n                preferredType?.unifyParentAndChildTypeChecks)) &&\n                preferredType !== undefined\n            ) {\n              typName = checkPostFix;\n\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        const prefType = preferredTypes?.[typeNodeName];\n        const directNameMatch = prefType !== undefined &&\n          !Object.values(preferredTypes).includes(typeNodeName);\n        const specificUnify = typeof prefType === 'object' &&\n          prefType?.unifyParentAndChildTypeChecks;\n        const unifiedSyntaxParentMatch = property && directNameMatch && (unifyParentAndChildTypeChecks || specificUnify);\n        isGenericMatch = isGenericMatch || Boolean(unifiedSyntaxParentMatch);\n\n        hasMatchingPreferredType = isGenericMatch ||\n          directNameMatch && !property;\n\n        return [\n          hasMatchingPreferredType, typName, isGenericMatch,\n        ];\n      };\n\n      /**\n       * Collect invalid type info.\n       * @param {string} type\n       * @param {string} value\n       * @param {string} tagName\n       * @param {string} nameInTag\n       * @param {number} idx\n       * @param {string|undefined} property\n       * @param {import('jsdoc-type-pratt-parser').NonRootResult} node\n       * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n       * @param {(string|false|undefined)[][]} invalidTypes\n       * @returns {void}\n       */\n      const getInvalidTypes = (type, value, tagName, nameInTag, idx, property, node, parentNode, invalidTypes) => {\n        let typeNodeName = type === 'JsdocTypeAny' ? '*' : value;\n\n        const [\n          hasMatchingPreferredType,\n          typName,\n          isGenericMatch,\n        ] = getPreferredTypeInfo(type, typeNodeName, parentNode, property);\n\n        let preferred;\n        let types;\n        if (hasMatchingPreferredType) {\n          const preferredSetting = preferredTypes[typName];\n          typeNodeName = typName === '[]' ? typName : typeNodeName;\n\n          if (!preferredSetting) {\n            invalidTypes.push([\n              typeNodeName,\n            ]);\n          } else if (typeof preferredSetting === 'string') {\n            preferred = preferredSetting;\n            invalidTypes.push([\n              typeNodeName, preferred,\n            ]);\n          } else if (preferredSetting && typeof preferredSetting === 'object') {\n            const nextItem = preferredSetting.skipRootChecking && jsdocTagsWithPossibleType[idx + 1];\n\n            if (!nextItem || !nextItem.name.startsWith(`${nameInTag}.`)) {\n              preferred = preferredSetting.replacement;\n              invalidTypes.push([\n                typeNodeName,\n                preferred,\n                preferredSetting.message,\n              ]);\n            }\n          } else {\n            utils.reportSettings(\n              'Invalid `settings.jsdoc.preferredTypes`. Values must be falsy, a string, or an object.',\n            );\n\n            return;\n          }\n        } else if (Object.entries(structuredTags).some(([\n          tag,\n          {\n            type: typs,\n          },\n        ]) => {\n          types = typs;\n\n          return tag === tagName &&\n            Array.isArray(types) &&\n            !types.includes(typeNodeName);\n        })) {\n          invalidTypes.push([\n            typeNodeName, types,\n          ]);\n        } else if (checkNativeTypes && !noDefaults && type === 'JsdocTypeName') {\n          preferred = checkNativeTypes(\n            preferredTypes, typeNodeName, preferred, parentNode, invalidTypes,\n          );\n        }\n\n        // For fixer\n        if (preferred) {\n          adjustNames(type, preferred, isGenericMatch, typeNodeName, node, parentNode);\n        }\n      };\n\n      for (const [\n        idx,\n        jsdocTag,\n      ] of jsdocTagsWithPossibleType.entries()) {\n        /** @type {(string|false|undefined)[][]} */\n        const invalidTypes = [];\n        let typeAst;\n\n        try {\n          typeAst = mode === 'permissive' ? tryParse(jsdocTag.type) : parse(jsdocTag.type, mode);\n        } catch {\n          continue;\n        }\n\n        const {\n          name: nameInTag,\n          tag: tagName,\n        } = jsdocTag;\n\n        traverse(typeAst, (node, parentNode, property) => {\n          const {\n            type,\n            value,\n          } =\n            /**\n             * @type {import('jsdoc-type-pratt-parser').NameResult}\n             */ (node);\n          if (![\n            'JsdocTypeAny', 'JsdocTypeName',\n          ].includes(type)) {\n            return;\n          }\n\n          getInvalidTypes(type, value, tagName, nameInTag, idx, property, node, parentNode, invalidTypes);\n        });\n\n        if (invalidTypes.length) {\n          const fixedType = stringify(typeAst);\n\n          /**\n           * @type {import('eslint').Rule.ReportFixer}\n           */\n          const fix = (fixer) => {\n            return fixer.replaceText(\n              jsdocNode,\n              sourceCode.getText(jsdocNode).replace(\n                `{${jsdocTag.type}}`,\n                `{${fixedType}}`,\n              ),\n            );\n          };\n\n          for (const [\n            badType,\n            preferredType = '',\n            msg,\n          ] of invalidTypes) {\n            const tagValue = jsdocTag.name ? ` \"${jsdocTag.name}\"` : '';\n            if (exemptTagContexts.some(({\n              tag,\n              types,\n            }) => {\n              return tag === tagName &&\n                (types === true || types.includes(jsdocTag.type));\n            })) {\n              continue;\n            }\n\n            report(\n              msg ||\n                `Invalid JSDoc @${tagName}${tagValue} type \"${badType}\"` +\n                (preferredType ? '; ' : '.') +\n                (preferredType ? `prefer: ${JSON.stringify(preferredType)}.` : ''),\n              preferredType ? fix : null,\n              jsdocTag,\n              msg ? {\n                tagName,\n                tagValue,\n              } : undefined,\n            );\n          }\n        }\n      }\n    },\n    {\n      iterateAllJsdocs: true,\n      meta: {\n        docs: {\n          description,\n          url,\n        },\n        ...(!overrideSettings || (Object.values(overrideSettings).some((os) => {\n          return os && typeof os === 'object' ?\n            /* c8 ignore next -- Ok */\n            os.replacement :\n            typeof os === 'string';\n        })) ?\n          {\n            fixable: 'code',\n          } :\n          {}\n        ),\n        schema,\n        type: 'suggestion',\n      },\n    },\n  );\n};\n"],"mappings":"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","ignoreList":[]}